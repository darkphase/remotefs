<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
 <head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <meta name="title" content="Remotefs, rfs_nss">
  <style type="text/css">
   body { 
      width: 17.5cm;
      font: 10pt Verdana, Arial, Helvetica, sans-serif;
      margin:0;
      padding-left: 1cm;
      padding-right:0.5cm; 
      border: solid 0px red;
   }
   p { text-align: justify; }
   a { font-weight: bold; }
   th { text-align: left; background-color: #cccccc; }
   table { border-collapse:collapse; border: 1px solid black; }
   td { border: 1px solid black; padding: 0.5em; vertical-align:top; }
   th { border: 1px solid black; padding: 0.5em; vertical-align:top; }
   .c { text-align: center; }
   .bl { text-align: left; background-color: #ddddff; }
   .ye { text-align: left; background-color: #ffffcc; }
   .super { position: relative; top: -0.4em; font-size: 0.5em; color:#cc0000; }
   .e { font-weight: bold; }
   pre { border: 1px blue solid; background: #ccccff; }
  </style>
  <script type="text/javascript">
   function viewImg(ImageName, ImageTitle, ImageWidth, ImageHeight)
   {
      var scroll = 'no';
      var SpacingLeft = (screen.availWidth - ImageWidth) / 2;
      var SpacingTop =  (screen.availHeight - ImageHeight) / 2;


      if (SpacingLeft < 0)
      {
         SpacingLeft = 0;
         ImageWidth = screen.availWidth -6;
         scroll = 1;
      }
      if (SpacingTop < 0)
      {
         SpacingTop = 0;
         ImageHeight = screen.availHeight - 32;
         scroll = 1;
      }

      winprops = 'height='+ImageHeight+',width='+ImageWidth+',top='+SpacingTop+',left='+SpacingLeft+',scrollbars='+scroll+',resizable=no';

      win = window.open('', ImageTitle, winprops);
      win.document.open();

      win.document.write('<html>\n <head>\n');
      win.document.write('  <title>'+ImageTitle+'</title>\n </head>\n');
      win.document.write(' <body leftmargin="0" topmargin="0" marginheight="0" marginwidth="0" onClick="window.close()" onBlur="window.close()">\n');
      win.document.write('  <img src="'+ImageName+'" alt="'+ImageTitle+'" title="'+ImageTitle+'" border="0" >\n');
      win.document.write(' </body>\n</html>\n');

      win.document.close();
      if (parseInt(navigator.appVersion) >= 4)
      {
         win.window.focus();
      }
   }
  </script>
 </head>
 <body>
  <h1>rfs_nss</h1>
  <h2>Introduction</h2>
  <p>
   On UNIX<sup>&reg;</sup> user and group are identified by a number and
   the user or group names returned by some applications (ls, file manager....)
   are retrieved from various databases which contains some rules concerning the
   user and group and of course the displayed user or group name.
  </p>
  <p>
   The database used are files, database, network services as ldap. and so on.
  </p>
  <p>
   The most important database for resolving the user/group name and id pairs
   are the files /etc/passwd and /etc/group.
  </p>
  <p>
   If we want to mount remote resources, the information's contained within
   the respective files on both systems may not be identical, this a big problem
   for resolving the correct ownership of the mounted resources
  </p>
  <p>
   The rfs_nss component try to make this easier and transparent. rfs_nss is
   a companion project for <a href="remotefs.html"><b>remotefs</b></a> a fast network file system which can
   be installed on home-NAS device which, mostly, have only limited performances.
  </p>
  <h2>How rfs_nss work</h2>
  <p>
   On the system there is a file <cite>/etc/nsswitch.conf</cite> which contain
   the name of the database which are to be used for resolving of some
   information's.
  </p>
  <p>
   The <b>N</b>ame <b>S</b>ervice <b>S</b>witch system read the configurations
   file and send the queries coming from the applications to the applicable
   registered databases.
  </p>
  <p>
   <b>Rfs_nss</b> implement such a database which allows to resolve the name of
   user and group which are not known in the client. This is useful if remotefs
   is compiled with <a href="acl.html">POSIX ACL</a> support and there are data shared by different
   users and the access to the files or directories is governed by ACL.
  </p>
  <p>
   The main component of <b>rfs_nss</b> is a library module which communicate
   with a little server, rfs_nss.
  </p>
  <p><b>Rfs_nss</b> know 3 working modes.
   <ol>
    <li>Name queried by application</li>
    <li>Stored mode, the information's are taken from a file</li>
    <li>Remote mode, the name are queried via a little client (rfs_nss_get) and
        a server (rfs_nss_rem) which must be installed on the <b>remotefs</b> server</li>
   </ol>
   Mode 2. can be combined with the other mode.
  </p>
  <p>
   The <b>rfs_nss</b> server get the name of user or group unknown on the client and generate
   an uid eg. gid and take already user uid and gid into account. 
  </p>
  <p>
   These name/id pairs can then be returned to the application and the
   <i>"real"</i> name can be displayed.
  </p>
  <p>
   All mode have advantage and disadvantage.
  <p>
   For the <i>Name queried by application</i> a typo error will create a wrong
   name/id pairs:
  </p>
  <pre>
$ setfacl -m u:bib:rw- file
</pre>
  <p>
   will automatically create a user <i>bib</i> instead of the using the data from
   <i>bob</i>, the user will not have chance to see that the command was wrong.
  </p>
  <p>
   The advantage is that you need only to install rfs_nss and the nss module
  </p>
  <p>
   The method <i>Remote mode</i> and <i>Stored mode</i> will not allows entering
    of wrong name and is therefore more secure.
  </p>
  <p>
   The <i>Remote mode</i> require that the server <b>rfs_nss_rem</b> must
    run on the <b>remotefs</b> server and that you must call <b>rfs_nss_get</b>
    on the client.
  <p>
   If you use the Store mode with the <b>Remote mode</b> you will nor need to
   Call each time you mount your remotefs resources launch <b>rfs_nss_get</b>. 
  </p>
  <p>
   The only information's passed across the network are the name for users
   and groups, the uis/gid are assigned by <b>rfs_nss</b> and the other
   information's are build in so a manner that there will be no security issue.
  </p>
  <h2>Naming of remote users</h2>
  <div style="float:right; padding-left:1em;">
   <img src="nautilus.png" alt="" style="width:5cm;" onClick="viewImg('nautilus.png','Nautilus', 630,599)"><br><i style="font-size:80%;">Nautilus: Click me</i><br><br>
   <img src="dolphin.png" alt="" style="width:5cm;" onClick="viewImg('dolphin.png','Dolphin', 668,475)"><br><i style="font-size:80%;">Dolphin: Click me</i>
  </div>
  <p>
   <b>Rfs</b> and the server <b>rsfd</b> don't use uid or gid but use the user
   and group name in order to transmit the ownership data for file and
   directories.
  </p>
  <p>
   For most case adding simply the name of the user/group name within the
   <b>rfs_nss</b> server shall be sufficient, If alice mount his resources,
   she will expect to see that the files are owned by themselves.
  </p>
  <p>
   If an unknown user is provided by the server, eg. <i>bob</i>, it may be
   good to display a name which show that the user is only known by the
   remote server.
  </p>
  <p>
    System users and groups may differ on the client an the server and
    collecting these information's for rfs_nss is not useful, so that
    such entries shall be avoided.
  </p>
  <p>
   For this case the user/group name can be appended with </i>@servername</i>.
   Doing so will show that this user is not known on the local system and
   that this name shall not be used for setting the ownership of a local
   file.
  </p>
  <p>
   There is also an other case for which using the <i>user@host</i>
   representation may be useful.
  </p>
  <p>
   If there is an unnamed owner (no user name is assigned to an uid) the
   use of a <i>"name"</i> as <i>1004@rfs_server</i> will allow to work
   with this possibly wrong data. The same apply fo course for groups.
  </p>
  <p>
   Without this name extension the uid can possibly is the same uid as
   for a user on the client and the displayed ownership will be wrong.
  </p>
  <h2>UID / GID assigned by rfs_nss</h2>
  <p>
   The <i>uid</i> and <i>gid</i> provided by rfs_nss are the result of an
   hash and in the range 10000 to 20000. Such values are normally not used
   on the systems. If a calculated value correspond to an id of the system,
   the next free id is assigned.
  </p>
  <p>
   Use of a hashed value has the advantage that the generated uid/gid will be
   always the same.
  </p>
  <h2>The different components provided by rds_nss</h2>
  <h3>libnss_rfs.so.2 / nss_rfs.so.1</h3>
  <p>
   This is the NSS module which must be installed on the server.
  </p>
  <h3>rfs_nss</h3>
  <p>
   rfs_nss is the server which generate the name/id pairs and which is queried
   by the NSS module. rfs_nss must run on the client.
  </p>
  <h3>rfs_nss_get</h3>
  <p>
    rfs_nss_get is a little client which contact the rfs_nss_rem server.
    rfs_nss_get must be launched on the remotefs client before starting
    rfs.
  </p>
  <p>
   rfs_nss_rem, ask its server for user and group name, inform rfs_nss about
   them and terminate.
  </p>
  <p>
   rfs_nss_get insert only unknow name to the rfs_nss database. The inserted
   names can be appended by &lt;@server&gt; if it is launched with
  -H &lt;address&gt; instead of -h &lt;ip_or address&gt;
  </p>
  <h3>rfs_nss_rem</h3>
  <p>
    This is the user and group name server and must be installed on the remotefs
    server.
  </p>
  <p>
    The name returned may ne all name found within the files /etc/passwd and
    /etc/group or limited to the non system names (uid/gid greater or equal to a
    given number).
  </p>
  <h3>rfs_nss_add, librfs_nss.so</h3>
  <p>
    rfs_nss_add allow passing user or group names to rfs_nss and is more an
    example as a useful program.
  </p>
  <p>
   Rfs_nss_add, use the library librfs_nss.so in order to communicate with the
   rfs_nss server. The library is loaded by rfs_nss_add and not by the OS so
   that rfs_nss_add is always executed.
  </p>
  <h2>Supported OS</h2>
  <table>
   <tr>
    <th> </th>
    <th>Linux</th>
    <th>openSolaris</th>
    <th>FreeBSD</th>
    <th>Mac OS X</th>
    <th>QNX</th>
   </tr>
   <tr class="ye">
    <td >rfs_nss</td>
    <td class="c">yes</td>
    <td class="c">yes</td>
    <td class="c">yes</td>
    <td class="c">no</td>
    <td class="c">no</td>
   <tr>
   <tr class="bl">
    <td >rfs_nss_rem</td>
    <td class="c">yes</td>
    <td class="c">yes</td>
    <td class="c">yes</td>
    <td class="c">yes</td>
    <td class="c">yes</td>
   <tr>
   <tr class="ye">
    <td >rfs_nss_get</td>
    <td class="c">yes</td>
    <td class="c">yes</td>
    <td class="c">yes</td>
    <td class="c">no</td>
    <td class="c">no</td>
   <tr>
  </table>
  <p>
   <b>Darwin/Mac OX X</b> use a very different API for resolving names.
  </p>
  <p>
   <b>QNX</b> is an embedded OS and there is no need for resolving user and/or
   group name on such systems..
  </p>
  <p>
   <b>Other POSIX systems</b> the various *BSD systems can probably be supported,
  </p>
  <p>
   <b>Notes</b> that the rfs_nss suite make only sense on systems which support POSIX
   ACL. The support is dependent from the used file system. On openSolaris, the
   default file system is ZFS. ZFS has support for the extended ACL (NFS4 ACL)
   which differ from the POSIX model. 
  </p>
  <p>
   On Linux, the extended ACL model is not supported.
  </p>
  <p>
   The FUSE implementation for some systems don't offer the support of
   extended attributes (FreeBSD, openSolaris).
  </p>
 </body>
</html>
